#!/usr/bin/env node
/**
 * i18n Gap Analysis Script
 * Detects missing translation keys and generates review document
 * NO external API calls - manual translation workflow
 *
 * Usage:
 *   npx tsx scripts/translate.ts
 *
 * @module translate
 * @author On Tour Dev Team
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// ============================================================================
// TYPES
// ============================================================================

type Lang = 'en' | 'es' | 'fr' | 'de' | 'it' | 'pt';

interface TranslationGap {
    lang: Lang;
    missingKeys: string[];
    coverage: number; // percentage 0-100
}

interface TranslationDiff {
    key: string;
    original: string; // English text
    translated: string; // Machine-translated text
    lang: Lang;
    autoGenerated: boolean;
}

// ============================================================================
// CONFIG
// ============================================================================

const SUPPORTED_LANGS: Lang[] = ['es', 'fr', 'de', 'it', 'pt']; // EN is the source
const I18N_FILE_PATH = join(process.cwd(), 'src/lib/i18n.ts');
const OUTPUT_DIR = join(process.cwd(), 'docs');
const OUTPUT_DIFFS_FILE = join(OUTPUT_DIR, 'i18n-auto-translations-pending-review.md');

// Google Translate API Language Codes
const LANG_CODE_MAP: Record<Lang, string> = {
    en: 'en',
    es: 'es',
    fr: 'fr',
    de: 'de',
    it: 'it',
    pt: 'pt',
};

// ============================================================================
// PARSE i18n.ts FILE
// ============================================================================

/**
 * Extract dictionary from i18n.ts file
 * Parses the DICT object structure
 */
function parseI18nFile(): Record<Lang, Record<string, string>> {
    const content = readFileSync(I18N_FILE_PATH, 'utf-8');

    // Extract DICT object
    const dictMatch = content.match(/const DICT: Record<Lang, Record<string, string>> = ({[\s\S]*?^});/m);
    if (!dictMatch) {
        throw new Error('Could not find DICT object in i18n.ts');
    }

    const dictStr = dictMatch[1];

    // Parse each language section
    const result: Record<string, Record<string, string>> = {};
    const langs: Lang[] = ['en', 'es', 'fr', 'de', 'it', 'pt'];

    for (const lang of langs) {
        const langRegex = new RegExp(`${lang}:\\s*{([\\s\\S]*?)}(?:\\s*,\\s*(?:${langs.join('|')}):)|${lang}:\\s*{([\\s\\S]*?)}\\s*$`, 'gm');
        const langMatch = dictStr.match(langRegex);

        if (!langMatch) {
            console.warn(`Warning: Could not find ${lang} dictionary section`);
            result[lang] = {};
            continue;
        }

        const langBlock = langMatch[0];
        const entries: Record<string, string> = {};

        // Parse key-value pairs
        // Format: 'key': 'value' or , 'key': 'value'
        const entryRegex = /['"]([^'"]+)['"]\s*:\s*['"]([^'"]*)['"]/g;
        let match;

        while ((match = entryRegex.exec(langBlock)) !== null) {
            const [, key, value] = match;
            entries[key] = value;
        }

        result[lang] = entries;
    }

    return result as Record<Lang, Record<string, string>>;
}

// ============================================================================
// GAP ANALYSIS
// ============================================================================

/**
 * Analyze translation gaps across all languages
 */
function analyzeGaps(dict: Record<Lang, Record<string, string>>): TranslationGap[] {
    const enKeys = Object.keys(dict.en);
    const gaps: TranslationGap[] = [];

    for (const lang of SUPPORTED_LANGS) {
        const langKeys = Object.keys(dict[lang] || {});
        const missingKeys = enKeys.filter(key => !dict[lang]?.[key]);
        const coverage = Math.round(((langKeys.length / enKeys.length) * 100) * 10) / 10;

        gaps.push({
            lang,
            missingKeys,
            coverage,
        });
    }

    return gaps;
}

// ============================================================================
// MANUAL TRANSLATION WORKFLOW (NO API)
// ============================================================================

/**
 * Generate placeholder entries for manual translation
 * No external API calls - purely gap detection
 */
function generateManualTranslationEntries(
    dict: Record<Lang, Record<string, string>>,
    gap: TranslationGap
): TranslationDiff[] {
    const diffs: TranslationDiff[] = [];

    console.log(`\nüìù Generating entries for ${gap.missingKeys.length} keys in ${gap.lang.toUpperCase()}...`);

    for (const key of gap.missingKeys) {
        const original = dict.en[key];

        if (!original) {
            console.warn(`‚ö†Ô∏è  Key "${key}" not found in English dictionary, skipping`);
            continue;
        }

        diffs.push({
            key,
            original,
            translated: '', // Empty - to be filled manually
            lang: gap.lang,
            autoGenerated: false,
        });
    }

    return diffs;
}

// ============================================================================
// OUTPUT GENERATION
// ============================================================================

/**
 * Generate Markdown report for manual translations
 */
function generateReviewMarkdown(
    gaps: TranslationGap[],
    allDiffs: TranslationDiff[]
): string {
    const lines: string[] = [];

    lines.push('# i18n Translation Gaps - Manual Translation Guide');
    lines.push('');
    lines.push('üìù **Manual translation required** - Fill in missing translations below');
    lines.push('');
    lines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
    lines.push('');
    lines.push('## Summary');
    lines.push('');
    lines.push('| Language | Current Coverage | Missing Keys | Status |');
    lines.push('|----------|------------------|--------------|--------|');

    for (const gap of gaps) {
        const langDiffs = allDiffs.filter(d => d.lang === gap.lang);
        const status = langDiffs.length > 0 ? '‚ö†Ô∏è Needs translation' : '‚úÖ Complete';
        lines.push(`| ${gap.lang.toUpperCase()} | ${gap.coverage}% | ${gap.missingKeys.length} | ${status} |`);
    }

    lines.push('');
    lines.push('---');
    lines.push('');

    // Detailed translations by language
    for (const lang of SUPPORTED_LANGS) {
        const langDiffs = allDiffs.filter(d => d.lang === lang);
        if (langDiffs.length === 0) continue;

        lines.push(`## ${lang.toUpperCase()} - ${langDiffs.length} Missing Translations`);
        lines.push('');
        lines.push('**Translation guidelines:**');
        lines.push('- Keep technical terms consistent (e.g., "show", "fee", "status")');
        lines.push('- Match tone: professional but friendly');
        lines.push('- Consider context: these appear in UI buttons, labels, and messages');
        lines.push('- Preserve placeholders: `{name}`, `{count}`, etc.');
        lines.push('');
        lines.push('### Quick Copy Format (for src/lib/i18n.ts)');
        lines.push('');
        lines.push('```typescript');
        for (const diff of langDiffs) {
            lines.push(`    , '${diff.key}': '' // TODO: translate "${diff.original}"`);
        }
        lines.push('```');
        lines.push('');
        lines.push('### Detailed Translation Table');
        lines.push('');
        lines.push('| Key | English Original | Your Translation |');
        lines.push('|-----|------------------|------------------|');

        for (const diff of langDiffs) {
            const key = diff.key.replace(/\|/g, '\\|');
            const original = diff.original.replace(/\|/g, '\\|').replace(/\n/g, ' ');
            lines.push(`| \`${key}\` | ${original} | _[translate here]_ |`);
        }

        lines.push('');
    }

    lines.push('---');
    lines.push('');
    lines.push('## Workflow');
    lines.push('');
    lines.push('### Option A: Direct Edit (Fastest)');
    lines.push('1. Copy the "Quick Copy Format" code blocks above');
    lines.push('2. Paste into corresponding language section in `src/lib/i18n.ts`');
    lines.push('3. Replace `// TODO: translate` comments with actual translations');
    lines.push('4. Test with language selector in app');
    lines.push('');
    lines.push('### Option B: Spreadsheet Translation (Team-Friendly)');
    lines.push('1. Export "Detailed Translation Table" to Google Sheets');
    lines.push('2. Share with native speakers (1 sheet per language)');
    lines.push('3. Collect translations in "Your Translation" column');
    lines.push('4. Copy translations back to `src/lib/i18n.ts`');
    lines.push('');
    lines.push('## Estimated Effort');
    lines.push('');
    lines.push('- **French**: ~4-6 hours (native speaker)');
    lines.push('- **German**: ~4-6 hours (native speaker)');
    lines.push('- **Italian**: ~4-6 hours (native speaker)');
    lines.push('- **Portuguese**: ~4-6 hours (native speaker)');
    lines.push('');
    lines.push('**Total**: 16-24 hours for all languages');
    lines.push('');
    lines.push('## Quality Checklist');
    lines.push('');
    lines.push('- [ ] All placeholders preserved (e.g., `{name}`, `{count}`)');
    lines.push('- [ ] Technical terms consistent across all strings');
    lines.push('- [ ] Tone matches English (professional but friendly)');
    lines.push('- [ ] Gender/plural agreement correct for language');
    lines.push('- [ ] Tested in-app with language toggle');
    lines.push('');

    return lines.join('\n');
}

/**
 * NO FILE GENERATION - Manual workflow only
 * Skip automatic file updates to avoid empty translations
 */

// ============================================================================
// MAIN
// ============================================================================

function main() {
    console.log('üìñ i18n Auto-Translation Tool\n');
    console.log('Step 1: Parsing i18n.ts...');

    const dict = parseI18nFile();
    const enKeyCount = Object.keys(dict.en).length;
    console.log(`‚úÖ Found ${enKeyCount} English keys`);

    console.log('\nStep 2: Analyzing gaps...');
    const gaps = analyzeGaps(dict);

    console.log('\nCurrent Coverage:');
    for (const gap of gaps) {
        const emoji = gap.coverage >= 90 ? 'üü¢' : gap.coverage >= 60 ? 'üü°' : 'üî¥';
        console.log(`  ${emoji} ${gap.lang.toUpperCase()}: ${gap.coverage}% (${gap.missingKeys.length} missing keys)`);
    }

    const totalMissing = gaps.reduce((sum, g) => sum + g.missingKeys.length, 0);
    console.log(`\nüìä Total missing translations: ${totalMissing}`);

    if (totalMissing === 0) {
        console.log('\n‚úÖ All languages have 100% coverage! No translations needed.');
        return;
    }

    console.log('\nStep 3: Generating translation templates...');

    const allDiffs: TranslationDiff[] = [];
    for (const gap of gaps) {
        if (gap.missingKeys.length === 0) continue;
        const diffs = generateManualTranslationEntries(dict, gap);
        allDiffs.push(...diffs);
    }

    console.log(`\n‚úÖ Generated ${allDiffs.length} entries across ${gaps.filter(g => g.missingKeys.length > 0).length} languages for manual translation`);

    console.log('\nStep 4: Generating translation guide...');
    const markdown = generateReviewMarkdown(gaps, allDiffs);
    writeFileSync(OUTPUT_DIFFS_FILE, markdown, 'utf-8');
    console.log(`‚úÖ Written: ${OUTPUT_DIFFS_FILE}`);

    console.log('\nüìã Summary:');
    console.log(`   - Missing keys found: ${totalMissing}`);
    console.log(`   - Translation guide: ${OUTPUT_DIFFS_FILE}`);

    console.log('\n‚úÖ Done! Next steps:');
    console.log('   1. Open docs/i18n-auto-translations-pending-review.md');
    console.log('   2. Copy "Quick Copy Format" code blocks for each language');
    console.log('   3. Paste into src/lib/i18n.ts and translate the strings');
    console.log('   4. Test in-app with language selector toggle');
    console.log('\n   OR use spreadsheet workflow (see guide for details)\n');
}

try {
    main();
} catch (error) {
    console.error('‚ùå Error:', error);
    process.exit(1);
}
